URL shortener: нужен защищённый URL shortener, чтобы считалось количество переходов по ссылкам. [Подумать, как РЕАЛИЗОВАТЬ БЕЗ WEB-части: чтобы переход по некоторым ссылкам был запаролен, или запретить прямой переход (только с некоторыми добавлениями)] Некоторые ссылки можно блокировать. Тот, кто создал ссылку, может её удалять.

//TODO: рассмотреть два подхода:
	1. При создании ссылки генерируется и возвращается специальный ключ, который позволяет удалить ссылку. Если он утерян, ссылку удалить нельзя.
	2. Использовать механизм регистрации и авторизации, чтобы каждый пользователь мог удалять свои ссылки.

ЯП: Go
БД: MongoDB

Структура БД url_shortener:

urls
--
_id				ObjectId
full_url 		string 				// изначальная ссылка
short_url		string				// сокращённая ссылка
hit_count		uint (or just int?) // счётчик переходов
secret			string				// пароль для доступа по ссылке (может быть пустым)
is_blocked		bool				// флаг, обозначающий, что ссылка заблокирована
created_user_id	string				// ID создавшего ссылку пользователя

users
--
_id 			ObjectId
login			string // поле должно быть уникальным
password_hash	string
email 			string // поле должно быть уникальным

Создание ссылок
	Ссылки можно добавлять и без авторизации, но в этом случае их нельзя удалить без доступа к базе данных
	Пользователь не может менять или удалять чужие ссылки

Алгоритм создания ссылок
	Пользователь добавляет новую ссылку, указывая исходный URL и необязательный параметр secret для её сокрытия ((пример результата: https://urlshortener.com/my_short_url/?secret=mysecret)
	Для ссылки генерируется соответствующая сокращённая ссылка и сохраняется в БД
		URL: имя_хоста/идентификатор_ссылки
	В ответ возвращается сгенерированный URL
	Если ссылку создаёт зарегистрированный и авторизованный пользователь, то при сохранении её в БД в поле created_user_id сохранится ID этого пользователя

Алгоритм открытия ссылок
	Для обработки переходов используется отдельный маршрут API GET /{short_url}, где short_url – короткий идентификатор ссылки
	При переходе выполняется проверка существования такой ссылки в БД
	Если её нет, возвращается ошибка со статусом 404
	Если она есть, то происходит проверка, заблокирована она или нет:
		Переход по заблокированным ссылкам должен быть запрещён (в ответ возвращается ошибка со статусом 403 Forbidden)
		В случае перехода по ссылкам, у которых заполнено поле secret, возможно два варианта:
			1. Значение secret верное, поэтому пользователь перенаправляется на исходную страницу.
			2. Значение secret неверное, поэтому пользователь получает в ответ ошибку со статусом 401 Not Authorized.

Регистрация и авторизация
	
	//TODO: Нужны ли разные роли? Думаю, пока можно обойтись без них
	//TODO: Понять, как описать в ТЗ сессию и хранение данных пользователя после авторизации
	Можно:
		создать нового пользователя
			после регистрации на указанную почту приходит письмо со ссылкой на подтверждение
		обновить логин/почту/пароль
		удалиться (учесть, что вместе с пользователем удаляются и все привязанные к нему ссылки)
		создать ссылку
		просмотреть список созданных пользователем ссылок
		заблокировать любую из созданных ссылок
		изменить ссылку
			при блокировке и изменении ссылок учесть, что пользователь может править только те ссылки, которые он создал сам (передавать из сессии)
	Восстановление пароля
		Для восстановления пароля нужно передать логин и/или email, после чего на почту пользователю придёт письмо со ссылкой на страницу сброса пароля

Хеширование паролей: MD5 + соль. В качестве соли использовать заранее сгенерированную сложную строку из 16 символов, включающих латинские буквы в разном регистре, цифры и специальные знаки: %, !, $ и т. д. Подробнее о том, как можно хешировать пароли в Go, можно почитать здесь: https://medium.com/@jcox250/password-hash-salt-using-golang-b041dc94cb72.

Алгоритм авторизации
	1) Пользователь вводит логин и пароль в форме;
	2) Выполняется запрос по маршруту POST /api/auth;
	3) Для пароля по описанному алгоритму высчитывается хеш, запросом к БД проверяется наличие введённой пары логин/пароль;
	4) Если совпадение не найдено, то пользователю возвращается ошибка авторизации;
	//TODO: возможно, стоит добавить в БД таблицу сессий?
	5) Если совпадение найдено, для пользователя создаётся сессия: он авторизован и получает доступ к своему личному кабинету, включая управление своей учётной записью и списком ссылок;
	6) При бездействии пользователя в течение 24 часов сессия сбрасывается, после чего требуется повторная авторизация;
	7) Кроме того, пользователь автоматически авторизуется после регистрации и переходу по ссылке из письма с подтверждением.

API:

Переход по ссылке
GET	/{short_url}
	Здесь может быть использован GET-параметр secret для доступа к "засекреченным" ссылкам. Если при переходе по этому маршруту в базе данных найдено соответствие short_url, то соответствующий счётчик hit_counter увеличивается на единицу.

urls
	--
	Получить список ссылок пользователя
	POST /api/urls_by_user_id 
		id
	POST /api/url
		urlModel
	POST /api/url/update
		urlModel
	DELETE /api/url/{id}

	//TODO: Как убедиться в том, что пользователь редактирует только собственные данные?
	// Видимо, нужен механизм сессий

users
	--
	POST /api/auth
		login
		password
	/api/user/create
		login
		password
	POST /api/user/update
		id
		login
		password
		email
	DELETE /api/user/{id}
	POST /api/user/reset_password
		login
		email
	Можно заполнить только login или только email: сброс пароля должен работать в обоих случаях (если соответствующее значение найдено в базе данных). Если переданы и login, и email, то проверяться на соответствие должны оба поля одновременно (то есть login и email должны принадлежать одному и тому же пользователю).
