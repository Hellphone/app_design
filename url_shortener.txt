URL shortener
Решил рассмотреть два подхода:
	1. При создании ссылки генерируется и возвращается специальный ключ, который позволяет удалить ссылку. Если он утерян, ссылку удалить нельзя.
	2. Использовать механизм регистрации и авторизации, чтобы каждый пользователь мог удалять свои ссылки.

Во втором случае у меня возникли сложности с описанием механизма сессий, чтобы можно было понять, что пользователь удаляет именно свою запись (и запретить ему удалять чужие).

URL shortener: нужен защищённый URL shortener, чтобы считалось количество переходов по ссылкам. [Подумать, как РЕАЛИЗОВАТЬ БЕЗ WEB-части: чтобы переход по некоторым ссылкам был запаролен, или запретить прямой переход (только с некоторыми добавлениями)] Некоторые ссылки можно блокировать. Тот, кто создал ссылку, может её удалять.

//TODO: рассмотреть два подхода:
	1. При создании ссылки генерируется и возвращается специальный ключ, который позволяет удалить ссылку. Если он утерян, ссылку удалить нельзя.
	2. Использовать механизм регистрации и авторизации, чтобы каждый пользователь мог удалять свои ссылки.

ЯП: Go
БД: MongoDB

Структура БД url_shortener:

urls
--
_id				ObjectId
full_url 		string 				// изначальная ссылка
short_url		string				// сокращённая ссылка
hit_count		uint (or just int?) // счётчик переходов
secret			string				// пароль для доступа по ссылке (может быть пустым)
is_blocked		bool				// флаг, обозначающий, что ссылка заблокирована
created_user_id	string				// ID создавшего ссылку пользователя

users
--
_id 			ObjectId
login			string
password_hash	string
email 			string

Создание ссылок
	Ссылки можно добавлять и без авторизации, но в этом случае их нельзя удалить без доступа к базе данных
	Пользователь не может менять или удалять чужие ссылки

Алгоритм создания ссылок
	Пользователь добавляет новую ссылку, указывая исходный URL и необязательный параметр secret для её сокрытия
	Если ссылка уже есть в базе, то возвращается ошибка
	Если ссылка новая, то для неё генерируется соответствующая сокращённая ссылка и сохраняется в БД
		URL: имя_хоста/идентификатор_ссылки
	В ответ возвращается сгенерированный URL
	Если ссылку создаёт зарегистрированный и авторизованный пользователь, то при сохранении её в БД в поле created_user_id сохранится ID этого пользователя

Алгоритм открытия ссылок
	Для обработки переходов используется отдельный маршрут API GET /{short_url}, где short_url – короткий идентификатор ссылки
	При переходе выполняется проверка существования такой ссылки в БД
	Если её нет, возвращается ошибка со статусом 404
	Если она есть, то происходит проверка, заблокирована она или нет:
		Переход по заблокированным ссылкам должен быть запрещён (в ответ возвращается ошибка со статусом 403 Forbidden)
		В случае перехода по ссылкам, у которых заполнено поле secret, возможно два варианта:
			1. Значение secret верное, поэтому пользователь перенаправляется на исходную страницу.
			2. Значение secret неверное, поэтому пользователь получает в ответ ошибку со статусом 401 Not Authorized.

Регистрация и авторизация
	
	//TODO: Нужны ли разные роли? Думаю, пока можно обойтись без них
	//TODO: Понять, как описать в ТЗ сессию и хранение данных пользователя после авторизации
	Можно:
		создать нового пользователя
			после регистрации на указанную почту приходит письмо со ссылкой на подтверждение
		обновить логин/почту/пароль
		удалиться (учесть, что вместе с пользователем удаляются и все привязанные к нему ссылки)
		создать ссылку
		просмотреть список созданных пользователем ссылок
		заблокировать любую из созданных ссылок
		изменить ссылку
			при блокировке и изменении ссылок учесть, что пользователь может править только те ссылки, которые он создал сам (передавать из сессии)
	Восстановление пароля
		Для восстановления пароля нужно передать логин и/или email, после чего на почту пользователю придёт письмо со ссылкой на страницу сброса пароля

Хеширование паролей: MD5 + соль. В качестве соли использовать заранее сгенерированную сложную строку из 16 символов, включающих латинские буквы в разном регистре, цифры и специальные знаки: %, !, $ и т. д. Подробнее о том, как можно хешировать пароли в Go, можно почитать здесь: https://medium.com/@jcox250/password-hash-salt-using-golang-b041dc94cb72.

API:

Переход по ссылке
GET	/{short_url}
	Здесь может быть использован GET-параметр secret для доступа к "засекреченным" ссылкам

urls
	--
	Получить список ссылок пользователя
	POST /api/urls_by_user_id 
		id
	POST /api/url
		urlModel
	POST /api/url/update
		urlModel
	DELETE /api/url/{id}



	//TODO: Как убедиться в том, что пользователь редактирует только собственные данные?
	// Видимо, нужен механизм сессий

users
	--
	POST /api/auth
		login
		password
	/api/user/create
		login
		password
	POST /api/user/update
		id
		login
		password
		email
	DELETE /api/user/{id}
	POST /api/user/reset_password
		id
		email
